\subsection{Version Control}
\label{sec:git}

In order to keep the workflow going at a good pace the teams elected to have version control, which is good practice in all projects. Git was used with a custom workflow shown below. \\

Have a server side repository with 4 initial persistent branches.
\begin{itemize}
\item master
\item staging
\item develop
\item release
\end{itemize}

The following naming convention for temporary branches was adopted: 

\begin{itemize}
\item SprintX.shortStoryName
\end{itemize}

NOTE: The temporary branches were deleted after each successful merge to the DEVELOP branch.

\subsection {Policies}
\begin{itemize}
\item master\\ \\
The 'master' branch was allowed only to contain Demo code. This is the code which contains ONLY the fully tested and integrated stories.  \\\\Tags were made here under the following convention:\\ \emph{SprintX.shortStoryName} \\\\
This was Jenkins build tool controlled area - No human user was allowed to operate in this branch. \\Jenkins is responsible for merging from 'release' to 'master' at the end of a sprint- in order to keep the branches synchronized and provide a fresh clean start for each sprint from working demo code.\\
\item release\\ \\
The 'release' branch was allowed only to contain individual stories which were completed and fully unit tested. Here the team could pick and choose which stories to include in a specific demo. This branch was also a Jenkins build tool area. \\Jenkins was responsible for integration testing and merging between 'release' and 'master'.
\item develop\\ \\
The 'develop' branch was allowed to contain all the code that was able to be compiled on the server and is where the human users would start their personal story branches. Also a Jenkins build tool area, the code here was considered in a "Story done and compiles but not yet tested" state.\\ Jenkins was responsible for unit testing and merging between 'develop' and 'release'.

\item staging \\ \\
The 'staging' branch contained all the dirty code and is where the human users would push all their code when finished for the end of the day. This was also the branch where Jenkins was used. Jenkins would pull all new commits and try to compile it, if it compiled then it would be merged with the 'develop' branch. If not, Jenkins would notify the users who had commited changes since the last failing commit.

\item SprintX.shortStoryName\\ \\
The branch's name contained the word 'Sprint' with the current sprint number appended by a short story name-typically the name written on the post-it note for example: Message\_Handler. A merge to the 'develop' branch would mean the story was considered done for the sprint but required testing by integration tools and Jenkins. This branch would be deleted after the tests were passed and a successful merge was complete.
\end{itemize}

For instructions on how to utilize this workflow see Appendix \ref{gitworkflow}.
